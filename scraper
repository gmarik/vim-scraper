#!/bin/env ruby

# Vimscripts scraper monster
# This command takes any mixture of arguments:
# - decimal number: the script id to scrape and save as a json file
# - .json file: the script to convert into a git repo
# - .git directory: the bare repo to dump into repostats

require 'rubygems'
require 'hpricot'
require 'open-uri'
require 'cgi'
require 'json'
require 'gitrb'
require 'zip/zipfilesystem' # rubyzip gem
require 'archive/tar/minitar' # minitar gem
require 'zlib'
require 'bzip2'
require 'mime/types'
require 'mimemagic'
require 'tmpdir'
require 'find'

# thoughts:
# We do everything we can to make it so you can drop the repo in bundles and just have it work.
# We reset permissions on extracted files -- usually when they're different it's a mistake.


$vimscripts_name = "vim-scripts"
$vimscripts_email = 'vimscripts@rinspin.com'

$repos_dir = 'repos'
$repostats_dir = 'repostats'
$scripts_dir = 'scripts'
$packages_dir = 'packages'

Dir.mkdir $scripts_dir unless test ?d, $scripts_dir
Dir.mkdir $repos_dir unless test ?d, $repos_dir
Dir.mkdir $repostats_dir unless test ?d, $repostats_dir
Dir.mkdir $packages_dir unless test ?d, $packages_dir



# http://github.com/hpricot/hpricot/issues#issue/25
# super ugly that hpricot manages to screw up charset encodings so badly.
# I'm patching hpricot directly as follows.  should probably convert this to a monkeypatch.
#
# --- a/lib/hpricot/traverse.rb	2010-08-25 02:07:55.288095773 -0700
# +++ b/lib/hpricot/traverse.rb	2010-08-25 02:08:02.403095712 -0700
# @@ -157,7 +157,7 @@
#      # HTML elements are removed.
#      def inner_text
#        if respond_to?(:children) and children
# -        children.map { |x| x.inner_text }.join
# +        children.map { |x| str = x.inner_text; str = str.dup.force_encoding('ISO-8859-1').encode('UTF-8') if str.encoding.to_s == 'ASCII-8BIT' || str.encoding.to_s == 'ISO-8859-1'; str }.join
#        else
#          ""
#        end
#
# --- a/lib/hpricot/builder.rb   2010-08-25 09:55:37.894992548 -0700
# +++ b/lib/hpricot/builder.rb   2010-08-25 09:55:23.880992337 -0700
# @@ -6,8 +6,9 @@
#  module Hpricot
#    # XML unescape
#    def self.uxs(str)
# -    str.to_s.
# -        gsub(/\&(\w+);/) { [NamedCharacters[$1] || ??].pack("U*") }.
# +    str = str.to_s
# +    str = str.dup.force_encoding('ISO-8859-1').encode('UTF-8') if str.encoding.to_s == 'ASCII-8BIT' || str.encoding.to_s == 'ISO-8859-1'
# +    str.gsub(/\&(\w+);/) { [NamedCharacters[$1] || ??].pack("U*") }.
#          gsub(/\&\#(\d+);/) { [$1.to_i].pack("U*") }
#    end
#
# Run './scraper 5' to see a script with a bunch of embedded nbsps
# that breaks hpricot horribly.
#
# encoding resources:
# http://yokolet.blogspot.com/2009/07/design-and-implementation-of-ruby-m17n.html
# http://yehudakatz.com/2010/05/05/ruby-1-9-encodings-a-primer-and-the-solution-for-rails/

module Hpricot
    module Traverse
        def inner_content
            if respond_to?(:children) and children
                children.map { |x| x.inner_content }.join
            else
                ''
            end
        end
    end

    class Elements < Array
        def inner_content
            map { |x| x.inner_content }.join
        end
    end

    class Text
        def inner_content
            CGI.unescapeHTML(content.to_s.gsub(/&nbsp;/, " "))
        end
    end

    class CData
        alias_method :inner_content, :content
    end
end




def scrape_author(user_id)
    $authors ||= []
    unless $authors[user_id.to_i]
        doc = open("http://www.vim.org/account/profile.php?user_id=#{user_id}") { |f| Hpricot(f) }
        doc.at('td[text()="user name"]').next_sibling.inner_content
        u = { :user_id => user_id }
        u[:user_name] = doc.at('td[text()="user name"]').next_sibling.inner_content
        u[:first_name] = doc.at('td[text()="first name"]').next_sibling.inner_content
        u[:last_name] = doc.at('td[text()="last name"]').next_sibling.inner_content
        u[:email] = doc.at('td[text()="email"]').next_sibling.inner_content
        u[:homepage] = doc.at('td[text()="homepage"]').next_sibling.inner_content
        $authors[user_id.to_i] = u
    end
    return $authors[user_id.to_i]
end


def script_id_to_url(script_id)
    "http://www.vim.org/scripts/script.php?script_id=#{script_id}"
end


def scrape_script(script_id)
    doc = open(script_id_to_url(script_id)) { |f| Hpricot(f) }
    if doc.search('title').inner_text == "Error : vim online"
        puts "Skipped #{script_id} -- doesn't exist."
        return nil
    end

    s = {:script_id => script_id}
    s[:name], s[:summary] = doc.search('.txth1').inner_content.split(" : ", 2)
    s[:script_type] = doc.at('td[text()="script type"]').parent.next_sibling.children.first.inner_content
    s[:description] = doc.at('td[text()="description"]').parent.next_sibling.children.first.inner_content.gsub("\r", "\n")
    s[:install_details] = doc.at('td[text()="install details"]').parent.next_sibling.children.first.inner_content.gsub("\r", "\n")
    # reject links with targets so download links in the description don't appear to be a version (script 1843)
    s[:versions] = doc.search('a[@href*="download_script.php?"]').select { |e| e.attributes['target'].empty? }.to_a.map do |a|
        v = {:url => 'http://www.vim.org/scripts/' + a.attributes['href'],
            :filename => a.inner_content}
        row = a.parent
        v[:script_version] = row.siblings_at(1).inner_content
        v[:date] = row.siblings_at(2).inner_content
        v[:vim_version] = row.siblings_at(3).inner_content
        v[:author] = scrape_author(row.siblings_at(4).at('a').attributes['href'].match(/\d+/)[0])
        v[:release_notes] = row.siblings_at(5).inner_content.gsub("\r", "\n")
        v
    end
    s
end


def fix_encoding(h)
    # see the Hpricot monkey patch above.  It gave us random encodings,
    # we need to force them back to their default before converting to utf8.
    # ugly!!
    if h.kind_of? Hash
        o = Hash.new
        h.each_pair { |k,v| o[fix_encoding(k)] = fix_encoding(v) }
        o
    elsif h.kind_of? Array
        a = Array.new
        h.each { |v| a.push fix_encoding(v) }
        a
    elsif h.kind_of? String
        if h.encoding.to_s == 'ASCII-8BIT' || h.encoding.to_s == 'ISO-8859-1'
            h = h.dup.force_encoding('ISO-8859-1').encode('UTF-8')
        end
        h
    else
        h
    end
end


def check_encoding(h)
    # recursively prints the encoding of every key/value/element etc
    if h.kind_of? Hash
        h.each_pair { |k,v| check_encoding(k); check_encoding(v) }
    elsif h.kind_of? Array
        h.each { |v| check_encoding(v) }
    elsif h.kind_of? String
        puts "#{h.encoding}: #{h[0..50]}"
    else
        h
    end
end


def filenameify(s)
    # replace any unsafe path chars
    s.gsub(/[^ A-Za-z0-9_\-!#\@\$^%&:;<?>+=(){|},.\[\]]/, '-')
end


def gittagify(s)
    # replace any chars git might take issue with (space, backslash, ^:)?]
    # interesting, git doesn't like it when a tag ends with a period
    s.gsub(/[^A-Za-z0-9_\-!#\@\$%&;<>+=(){|},.\]]/, '-').gsub(/\.$/, '.-')
end


def script_version(version)
    # some scripts don't assign a version so just use the date
    s = version['script_version']
    s = version['date'] if s =~ /^\s*$/
    s
end


def write_script(script)
    return unless script
    filename = File.join($scripts_dir, "#{'%04d' % script[:script_id]} - #{filenameify(script[:name])}.json")
    puts "Scraped #{filename}"
    File.open(filename, 'w') { |f|
        farg = fix_encoding(script)
        # check_encoding(farg)
        f.write(JSON.pretty_generate(farg))
    }
end


def download_file(url, dest)
    puts "  downloading #{url} to #{dest}"
    open(url, 'rb') { |u|
        File.open(dest, 'wb') { |f|
            f.write(u.read)
        }
    }
end


def copy_file(filename, contents)
    $repo.root[filename] = Gitrb::Blob.new(:data => contents)
end


def smart_copy_file(script, filename, contents)
    if filename =~ /^[^\/]+\.vim/
        # a .vim file in the root directory
        if script['script_type'] == 'utility'
            copy_file("plugin/" + filename, contents)
        elsif script['script_type'] == 'syntax'
            copy_file("syntax/" + filename, contents)
        else
            raise "Don't know where to put #{filename} for #{script['script_type']}"
        end
    elsif filename =~ /^[^\/]+\.txt/
        copy_file("doc/" + filename, contents)
    elsif filename =~ /^[^\/]+\/(after|autoload|bin|colors|doc|ftdetect|ftplugin|indent|plugin|syntax)\/([^\/]+)$/
        # developer put vimfiles in a subdir, i.e. fixit/plugin/fixit.vim.
        copy_file("#{$1}/#{$2}", contents)
    else
        copy_file(filename, contents)
    end
end


def unvimball(script, vimball)
    Dir.mktmpdir($vimscripts_name) do |tmpdir|
        cmd = ['/usr/bin/vim', vimball, '-X', '-n', '-c', ":set runtimepath=#{tmpdir},$VIMRUNTIME", '-c', ':so %', '-c', ':q']
        raise "couldn't run #{cmd.join(' ')}: #{$?}" unless system(*cmd)
        Find.find(tmpdir) do |path|
            next if test(?d, path)
            localpath = path.sub(tmpdir, '').sub(/^\/+/, '')
            next if localpath == '.VimballRecord' || localpath == 'doc/tags'
            smart_copy_file(script, localpath, File.read(path))
        end
        # mktmpdir automatically blows everything away
    end
end


def copy_zipfile(script, zip_path)
    Zip::ZipFile.open(zip_path) do |zipfile|
        zipfile.each do |entry|
            next unless entry.file?
            raise "add symlinks!" if entry.symlink?
            smart_copy_file(script, entry.name, entry.get_input_stream.read)
        end
    end
end


def copy_tarfile(script, tarfile)
    Archive::Tar::Minitar::Reader.open(tarfile) do |tf|
        tf.each_entry do |entry|
            next unless entry.file?
            smart_copy_file(script, entry.full_name, entry.read)
        end
    end
end


def ungzip(file)
    Zlib::GzipReader.open(file) { |gz| yield(gz) }
end


def unbzip2(file)
    Bzip2::Reader.open(file) { |bz| yield(bz) }
end


def sense_tarfile(script, filename, infile)
    contents = infile.read
    if MimeMagic.by_magic(contents) == 'application/x-tar'
        copy_tarfile(script, StringIO.new(contents))
    else
        smart_copy_file(script, filename, contents)
    end
end


def download_package(version, script)
    pkgname = "#{version['date']} #{filenameify(script_version(version))} #{filenameify(version['filename'])}"
    pkgdir = File.join($packages_dir, "#{'%04d' % script['script_id']} - #{script['name']}")
    Dir.mkdir pkgdir unless test ?d, pkgdir
    pkgfile = File.join(pkgdir, pkgname)
    download_file(version['url'], pkgfile) unless test ?f, pkgfile
    return pkgfile
end


# .set?!  http://www.vim.org/scripts/script.php?script_id=45
$textext = %w{c cpp h pl pm py rb set tcl txt vim}.map { |x| "\\.#{x}$" }.join('|')

def sense_file(actual_name, pkgfile)
    # some files lie about their type (claim to be .zips but are just .vim files).  fix em.
    extension_type = MIME::Types.type_for(actual_name)
    magic_type = File.open(pkgfile) { |f| MimeMagic.by_magic(f) }
    if extension_type.include? magic_type
        # we're good, extension and magic match up
    else
        # need to figure out what's going on and fix it.
        if (magic_type.nil? && actual_name =~ /#{$textext}/) || magic_type.text?
            # no problem, it's a textfile
        elsif actual_name =~ /\.vba$/
            # arg, a vimball.  let it through.
        elsif extension_type.include? 'application/zip' then
            if magic_type.nil?
                # extension claims zipfile but magic disagrees.  assume it's a vimfile.
                # http://www.vim.org/scripts/script.php?script_id=29
                actual_name = actual_name.sub(/\.zip$/, '') + '.vim'
            else
                raise "unknown failed zip type for #{actual_name}: #{magic_type}"
            end
        elsif magic_type == 'application/zip'
            actual_name += '.zip'
        elsif magic_type == 'application/x-gzip'
            actual_name += '.gz'
        else raise "differing mime types for #{actual_name}, ext claims #{extension_type} but magic is #{magic_type}"
        end
    end
    return actual_name
end


def add_version(version, script)
    # adds all the files in the package to the $repo
    pkgfile = download_package(version, script)
    actual_name = sense_file(version['filename'], pkgfile)

    case actual_name
    when /#{$textext}/ then smart_copy_file(script, actual_name, File.read(pkgfile))
    when /\.zip$/ then copy_zipfile(script, pkgfile)
    when /\.tar$/ then File.open(pkgfile, 'r') { |file| copy_tarfile(script, file) }
    when /\.t?gz$/ then ungzip(pkgfile) { |contents| sense_tarfile(script, version['filename'].sub(/\.gz$/, ''), contents) }
    when /\.t?bz2?$/ then raise "check bz"; unbzip2(pkgfile) { |contents| sense_tarfile(script, version['filename'].sub(/\.bz2?$/, ''), contents) }
    when /\.vba$/ then unvimball(script, pkgfile)
    else raise "unknown filetype: #{actual_name}"
    end
end


def tag_version(version)
    ENV['GIT_COMMITTER_NAME'] = $vimscripts_name
    ENV['GIT_COMMITTER_EMAIL'] = $vimscripts_email
    # don't need to chdir before git tag since Gitrb set GIT_DIR.  :-/
    sver = script_version(version)
    $repo.git_tag('-a', gittagify(sver), '-m', "tag #{sver}")
    ENV.delete('GIT_COMMITTER_NAME')
    ENV.delete('GIT_COMMITTER_EMAIL')
end


def find_version(version)
    tagname = gittagify(script_version(version))
    tagref = "#{$repo.path}/refs/tags/#{tagname}"
    return nil unless test ?f, tagref
    id = File.read(tagref)
    tag = $repo.get(id)
    raise "not a commit tag" unless tag.tagtype == 'commit'
    return tag
end


def read_script(script)
    $repo_path = File.join($repos_dir, "#{'%04d' % script['script_id']} - #{script['name']}.git")
    # if gitrb is dying on the following line, you need this fix:
    #   http://github.com/bronson/gitrb/commit/ae931ad7fe8309bcd2c4b9cc582c1500fa152e8d
    $repo = Gitrb::Repository.new(:path => $repo_path, :bare => true, :create => true)

    # token = File.read('token').chomp
    # github = Octopussy::Client.new(:login => 'vim-scripts', :token => token)

    committer = Gitrb::User.new($vimscripts_name, $vimscripts_email)
    puts "Processing script #{script['script_id']}: #{script['name']}"
    script['versions'].reverse.each do |version|
        author = Gitrb::User.new("#{version['author']['first_name']} #{version['author']['last_name']}",
                                 version['author']['email'], Time.new(*version['date'].split('-'), 0, 0, 0, 0))
        if find_version(version)
            puts "  skipped #{version['filename']} #{version['date']} #{script_version(version)}"
        else
            puts "  adding #{version['filename']} #{version['date']} #{script_version(version)}"
            $repo.transaction(version['release_notes'], author, committer) {
                # delete all existing blobs in this commit
                $repo.root.to_a.map { |a| $repo.root.delete(a.first) }
                add_version(version, script)
                copy_file('README', "This is a mirror of #{script_id_to_url(script['script_id'])}\n\n" + script['description'] + "\n") unless $repo.root['README']
            }
            tag_version(version)
        end
    end
end


def dump_repo(repo)
    repo = repo.gsub /\/$/, ''
    ENV['GIT_DIR'] = repo
    log = `git log --pretty=fuller --decorate=full --stat`
    # remove every line with a CommitDate since that's horribly variable
    log = log.each_line.reduce([]) { |a,v|
        v.gsub!(/^commit\s+[0-9A-Fa-f]*/, 'commit SHA1SHA1SHA1');
        a.push(v) unless v =~ /^CommitDate: /;
        a }.join
    ENV.delete('GIT_DIR')
    filename = File.join($repostats_dir, File.basename(repo).gsub(/\.git$/, '') + '.stats')
    puts "Stats in #{filename}"
    File.open(filename, 'w') { |f|
        f.write log
    }
end


raise "specify some scripts to scrape" if ARGV.empty?
ARGV.each do |arg|
    if arg =~ /^\d+$/
        write_script(scrape_script(arg))
    elsif test ?f, arg
        read_script(JSON.parse(File.read(arg)))
    elsif test ?d, arg
        dump_repo(arg)
    else
        raise "Could not recognize argument #{arg}"
    end
end

