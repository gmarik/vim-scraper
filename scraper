#!/bin/env ruby

require 'rubygems'
require 'hpricot'
require 'open-uri'
require 'json'
require 'gitrb'
require 'zip/zipfilesystem' # rubyzip gem


$vimscripts_name = "vim-scripts"
$vimscripts_email = 'vimscripts@rinspin.com'

$repos_dir = 'repos'
$scripts_dir = 'scripts'
$packages_dir = 'packages'

Dir.mkdir $scripts_dir unless test ?d, $scripts_dir
Dir.mkdir $repos_dir unless test ?d, $repos_dir
Dir.mkdir $packages_dir unless test ?d, $packages_dir


def scrape_author(user_id)
    $authors ||= []
    unless $authors[user_id.to_i]
        doc = open("http://www.vim.org/account/profile.php?user_id=#{user_id}") { |f| Hpricot(f) }
        doc.at('td[text()="user name"]').next_sibling.inner_text
        u = { :user_id => user_id }
        u[:user_name] = doc.at('td[text()="user name"]').next_sibling.inner_text
        u[:first_name] = doc.at('td[text()="first name"]').next_sibling.inner_text
        u[:last_name] = doc.at('td[text()="last name"]').next_sibling.inner_text
        u[:email] = doc.at('td[text()="email"]').next_sibling.inner_text
        u[:homepage] = doc.at('td[text()="homepage"]').next_sibling.inner_text
        $authors[user_id.to_i] = u
    end
    return $authors[user_id.to_i]
end


def script_id_to_url(script_id)
    "http://www.vim.org/scripts/script.php?script_id=#{script_id}"
end


def scrape_script(script_id)
    doc = open(script_id_to_url(script_id)) { |f| Hpricot(f) }
    s = {:script_id => script_id}
    s[:name], s[:summary] = doc.search('.txth1').inner_text.split(" : ", 2)
    s[:script_type] = doc.at('td[text()="script type"]').parent.next_sibling.children.first.inner_text
    s[:description] = doc.at('td[text()="description"]').parent.next_sibling.children.first.inner_text.gsub("\r", "\n")
    s[:install_details] = doc.at('td[text()="install details"]').parent.next_sibling.children.first.inner_text.gsub("\r", "\n")
    s[:versions] = doc.search('a[@href*="download_script.php?"]').to_a.map do |a|
        v = {:url => 'http://www.vim.org/scripts/' + a.attributes['href'],
            :filename => a.inner_text}
        row = a.parent
        v[:script_version] = row.siblings_at(1).inner_text
        v[:date] = row.siblings_at(2).inner_text
        v[:vim_version] = row.siblings_at(3).inner_text
        v[:author] = scrape_author(row.siblings_at(4).at('a').attributes['href'].match(/\d+/)[0])
        v[:release_notes] = row.siblings_at(5).inner_text.gsub("\r", "\n")
        v
    end
    s
end


def write_script(script)
    filename = File.join($scripts_dir, script[:name] + '.json')
    puts "scraped #{filename}"
    File.open(filename, 'w') { |f|
        f.write(JSON.pretty_generate(script))
    }
end


def download(url, dest)
    puts "Downloading #{url} to #{dest}"
    open(url, 'rb') { |u|
        File.open(dest, 'wb') { |f|
            f.write(u.read)
        }
    }
end


def copy_file(filename, contents)
    $repo.root[filename] = Gitrb::Blob.new(:data => contents)
end


def smart_copy_file(script, filename, contents)
    if filename =~ /^[^\/]+\.vim/
        # a .vim file in the root directory
        if script['script_type'] == 'utility'
            copy_file("plugin/" + filename, contents)
        elsif script['script_type'] == 'syntax'
            copy_file("syntax/" + filename, contents)
        else
            raise "Don't know where to put #{filename} for #{script['script_type']}"
        end
    else
        copy_file(filename, contents)
    end
end


def copy_zipfile(zip_path)
    Zip::ZipFile.open(zip_path) do |zipfile|
        zipfile.each do |file|
            raise "add symlinks!" if file.symlink?
            copy_file(file.name, file.get_input_stream.read)
        end
    end
end


def add_version(version, script)
    pkgname = "#{version['date']} #{version['script_version']} #{version['filename']}"
    pkgdir = File.join($packages_dir, script['name'])
    Dir.mkdir pkgdir unless test ?d, pkgdir
    pkgfile = File.join(pkgdir, pkgname)
    download(version['url'], pkgfile) unless test ?f, pkgfile

    case pkgfile
    when /\.vim$/ then smart_copy_file(script, version['filename'], File.read(pkgfile))
    when /\.zip$/ then copy_zipfile(pkgfile)
    when /\.tar\.gz$|\.tgz$/ then puts "can't handle .tar.gz"
    when /\.tar\.bz2?$|\.tbz2?$/ then puts "can't handle .tar.bz"
    when /\.gz$/ then puts "can't handle .gz"
    when /\.bz2?$/ then puts "can't handle .bz"
    when /\.vba$/ then puts "can't handle .vba"
    end
end


def tag_version(version)
    ENV['GIT_COMMITTER_NAME'] = $vimscripts_name
    ENV['GIT_COMMITTER_EMAIL'] = $vimscripts_email
    # don't need to chdir before git tag since Gitrb set GIT_DIR.  :-/
    $repo.git_tag('-a', version['script_version'], '-m', "tag #{version['script_version']}")
    ENV.delete('GIT_COMMITTER_NAME')
    ENV.delete('GIT_COMMITTER_EMAIL')
end


def find_version(version)
    tagref = "#{$repo.path}/refs/tags/#{version['script_version']}"
    return nil unless test ?f, tagref
    id = File.read(tagref)
    tag = $repo.get(id)
    raise "not a commit tag" unless tag.tagtype == 'commit'
    return tag
end


def read_script(script)
    $repo_path = File.join($repos_dir, script['name'] + '.git')
    # if gitrb is dying on the following line, you need this fix:
    #   http://github.com/bronson/gitrb/commit/ae931ad7fe8309bcd2c4b9cc582c1500fa152e8d
    $repo = Gitrb::Repository.new(:path => $repo_path, :bare => true, :create => true)

    # token = File.read('token').chomp
    # github = Octopussy::Client.new(:login => 'vim-scripts', :token => token)

    committer = Gitrb::User.new($vimscripts_name, $vimscripts_email)
    puts "Processing script #{script['script_id']}: #{script['name']}"
    script['versions'].reverse.each do |version|
        author = Gitrb::User.new("#{version['author']['first_name']} #{version['author']['last_name']}",
                                 version['author']['email'], Time.new(*version['date'].split('-'), 0, 0, 0, 0))
        if find_version(version)
            puts "  skipped #{version['filename']} #{version['date']} #{version['script_version']}"
        else
            $repo.transaction(version['release_notes'], author, committer) {
                # delete all existing blobs in this commit
                $repo.root.to_a.map { |a| $repo.root.delete(a.first) }
                add_version(version, script)
                copy_file('README', "This is a mirror of #{script_id_to_url(script['script_id'])}\n\n" + script['description'] + "\n") unless $repo.root['README']
            }
            tag_version(version)
            puts "  added #{version['filename']} #{version['date']} #{version['script_version']}"
        end
    end
end


raise "specify some scripts to scrape" if ARGV.empty?
ARGV.each do |arg|
    if arg =~ /^\d+$/
        write_script(scrape_script(arg))
    elsif File.exist?(arg)
        read_script(JSON.parse(File.read(arg)))
    else
        raise "Could not recognize argument #{arg}"
    end
end

