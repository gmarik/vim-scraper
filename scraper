#!/bin/env ruby

# Vimscripts scraper monster
# This command takes any mixture of arguments:
# - decimal number: the script id to scrape and save as a json file
# - .json file: the script to convert into a git repo
# - .git directory: the bare repo to dump into repostats

require 'rubygems'
require 'hpricot'
require 'open-uri'
require 'cgi'
require 'json'
require 'gitrb'
require 'zip/zipfilesystem' # rubyzip gem


$vimscripts_name = "vim-scripts"
$vimscripts_email = 'vimscripts@rinspin.com'

$repos_dir = 'repos'
$repostats_dir = 'repostats'
$scripts_dir = 'scripts'
$packages_dir = 'packages'

Dir.mkdir $scripts_dir unless test ?d, $scripts_dir
Dir.mkdir $repos_dir unless test ?d, $repos_dir
Dir.mkdir $repostats_dir unless test ?d, $repostats_dir
Dir.mkdir $packages_dir unless test ?d, $packages_dir



# http://github.com/hpricot/hpricot/issues#issue/25
# super ugly that hpricot manages to screw up charset encodings so badly.
# I'm patching hpricot directly as follows.  should probably convert this to a monkeypatch.
#
# --- a/lib/hpricot/traverse.rb	2010-08-25 02:07:55.288095773 -0700
# +++ b/lib/hpricot/traverse.rb	2010-08-25 02:08:02.403095712 -0700
# @@ -157,7 +157,7 @@
#      # HTML elements are removed.
#      def inner_text
#        if respond_to?(:children) and children
# -        children.map { |x| x.inner_text }.join
# +        children.map { |x| str = x.inner_text; str = str.dup.force_encoding('ISO-8859-1').encode('UTF-8') if str.encoding.to_s == 'ASCII-8BIT' || str.encoding.to_s == 'ISO-8859-1'; str }.join
#        else
#          ""
#        end
#
# --- a/lib/hpricot/builder.rb   2010-08-25 09:55:37.894992548 -0700
# +++ b/lib/hpricot/builder.rb   2010-08-25 09:55:23.880992337 -0700
# @@ -6,8 +6,9 @@
#  module Hpricot
#    # XML unescape
#    def self.uxs(str)
# -    str.to_s.
# -        gsub(/\&(\w+);/) { [NamedCharacters[$1] || ??].pack("U*") }.
# +    str = str.to_s
# +    str = str.dup.force_encoding('ISO-8859-1').encode('UTF-8') if str.encoding.to_s == 'ASCII-8BIT' || str.encoding.to_s == 'ISO-8859-1'
# +    str.gsub(/\&(\w+);/) { [NamedCharacters[$1] || ??].pack("U*") }.
#          gsub(/\&\#(\d+);/) { [$1.to_i].pack("U*") }
#    end
#
# Run './scraper 5' to see a script with a bunch of embedded nbsps
# that breaks hpricot horribly.
#
# encoding resources:
# http://yokolet.blogspot.com/2009/07/design-and-implementation-of-ruby-m17n.html
# http://yehudakatz.com/2010/05/05/ruby-1-9-encodings-a-primer-and-the-solution-for-rails/

module Hpricot
    module Traverse
        def inner_content
            if respond_to?(:children) and children
                children.map { |x| x.inner_content }.join
            else
                ''
            end
        end
    end

    class Elements < Array
        def inner_content
            map { |x| x.inner_content }.join
        end
    end

    class Text
        def inner_content
            CGI.unescapeHTML(content.to_s.gsub(/&nbsp;/, " "))
        end
    end

    class CData
        alias_method :inner_content, :content
    end
end




def scrape_author(user_id)
    $authors ||= []
    unless $authors[user_id.to_i]
        doc = open("http://www.vim.org/account/profile.php?user_id=#{user_id}") { |f| Hpricot(f) }
        doc.at('td[text()="user name"]').next_sibling.inner_content
        u = { :user_id => user_id }
        u[:user_name] = doc.at('td[text()="user name"]').next_sibling.inner_content
        u[:first_name] = doc.at('td[text()="first name"]').next_sibling.inner_content
        u[:last_name] = doc.at('td[text()="last name"]').next_sibling.inner_content
        u[:email] = doc.at('td[text()="email"]').next_sibling.inner_content
        u[:homepage] = doc.at('td[text()="homepage"]').next_sibling.inner_content
        $authors[user_id.to_i] = u
    end
    return $authors[user_id.to_i]
end


def script_id_to_url(script_id)
    "http://www.vim.org/scripts/script.php?script_id=#{script_id}"
end


def scrape_script(script_id)
    doc = open(script_id_to_url(script_id)) { |f| Hpricot(f) }
    s = {:script_id => script_id}
    s[:name], s[:summary] = doc.search('.txth1').inner_content.split(" : ", 2)
    s[:script_type] = doc.at('td[text()="script type"]').parent.next_sibling.children.first.inner_content
    s[:description] = doc.at('td[text()="description"]').parent.next_sibling.children.first.inner_content.gsub("\r", "\n")
    s[:install_details] = doc.at('td[text()="install details"]').parent.next_sibling.children.first.inner_content.gsub("\r", "\n")
    s[:versions] = doc.search('a[@href*="download_script.php?"]').to_a.map do |a|
        v = {:url => 'http://www.vim.org/scripts/' + a.attributes['href'],
            :filename => a.inner_content}
        row = a.parent
        v[:script_version] = row.siblings_at(1).inner_content
        v[:date] = row.siblings_at(2).inner_content
        v[:vim_version] = row.siblings_at(3).inner_content
        v[:author] = scrape_author(row.siblings_at(4).at('a').attributes['href'].match(/\d+/)[0])
        v[:release_notes] = row.siblings_at(5).inner_content.gsub("\r", "\n")
        v
    end
    s
end


def fix_encoding(h)
    # see the Hpricot monkey patch above.  It gave us random encodings,
    # we need to force them back to their default before converting to utf8.
    # ugly!!
    if h.kind_of? Hash
        o = Hash.new
        h.each_pair { |k,v| o[k] = fix_encoding(v) }
        o
    elsif h.kind_of? Array
        a = Array.new
        h.each { |v| a.push fix_encoding(v) }
        a
    elsif h.kind_of? String
        if h.encoding.to_s == 'ASCII-8BIT'
            h = h.dup.force_encoding('ISO-8859-1').encode("UTF-8")
        end
        h
    else
        h
    end
end


def check_encoding(h)
    # recursively prints the encoding of every key/value/element etc
    if h.kind_of? Hash
        h.each_pair { |k,v| check_encoding(k); check_encoding(v) }
    elsif h.kind_of? Array
        h.each { |v| check_encoding(v) }
    elsif h.kind_of? String
        puts "#{h.encoding}: #{h[0..50]}"
    else
        h
    end
end


def write_script(script)
    filename = File.join($scripts_dir, "#{'%04d' % script[:script_id]} - #{script[:name]}.json")
    puts "Scraped #{filename}"
    File.open(filename, 'w') { |f|
        farg = fix_encoding(script)
        # check_encoding(farg)
        f.write(JSON.pretty_generate(farg))
    }
end


def download(url, dest)
    puts "  downloading #{url} to #{dest}"
    open(url, 'rb') { |u|
        File.open(dest, 'wb') { |f|
            f.write(u.read)
        }
    }
end


def copy_file(filename, contents)
    $repo.root[filename] = Gitrb::Blob.new(:data => contents)
end


def smart_copy_file(script, filename, contents)
    if filename =~ /^[^\/]+\.vim/
        # a .vim file in the root directory
        if script['script_type'] == 'utility'
            copy_file("plugin/" + filename, contents)
        elsif script['script_type'] == 'syntax'
            copy_file("syntax/" + filename, contents)
        else
            raise "Don't know where to put #{filename} for #{script['script_type']}"
        end
    elsif filename =~ /^[^\/]+\.txt/
        copy_file("doc/" + filename, contents)
    else
        copy_file(filename, contents)
    end
end


def copy_zipfile(script, zip_path)
    Zip::ZipFile.open(zip_path) do |zipfile|
        zipfile.each do |file|
            raise "add symlinks!" if file.symlink?
            smart_copy_file(script, file.name, file.get_input_stream.read)
        end
    end
end


def add_version(version, script)
    pkgname = "#{version['date']} #{version['script_version']} #{version['filename']}"
    pkgdir = File.join($packages_dir, script['name'])
    Dir.mkdir pkgdir unless test ?d, pkgdir
    pkgfile = File.join(pkgdir, pkgname)
    download(version['url'], pkgfile) unless test ?f, pkgfile

    case pkgfile
    when /\.vim$/ then smart_copy_file(script, version['filename'], File.read(pkgfile))
    when /\.zip$/ then copy_zipfile(script, pkgfile)
    when /\.tar\.gz$|\.tgz$/ then raise "can't handle .tar.gz"
    when /\.tar\.bz2?$|\.tbz2?$/ then raise "can't handle .tar.bz"
    when /\.gz$/ then raise "can't handle .gz"
    when /\.bz2?$/ then raise "can't handle .bz"
    when /\.vba$/ then raise "can't handle .vba"
    end
end


def tag_version(version)
    ENV['GIT_COMMITTER_NAME'] = $vimscripts_name
    ENV['GIT_COMMITTER_EMAIL'] = $vimscripts_email
    # don't need to chdir before git tag since Gitrb set GIT_DIR.  :-/
    $repo.git_tag('-a', version['script_version'], '-m', "tag #{version['script_version']}")
    ENV.delete('GIT_COMMITTER_NAME')
    ENV.delete('GIT_COMMITTER_EMAIL')
end


def find_version(version)
    tagref = "#{$repo.path}/refs/tags/#{version['script_version']}"
    return nil unless test ?f, tagref
    id = File.read(tagref)
    tag = $repo.get(id)
    raise "not a commit tag" unless tag.tagtype == 'commit'
    return tag
end


def read_script(script)
    $repo_path = File.join($repos_dir, script['name'] + '.git')
    # if gitrb is dying on the following line, you need this fix:
    #   http://github.com/bronson/gitrb/commit/ae931ad7fe8309bcd2c4b9cc582c1500fa152e8d
    $repo = Gitrb::Repository.new(:path => $repo_path, :bare => true, :create => true)

    # token = File.read('token').chomp
    # github = Octopussy::Client.new(:login => 'vim-scripts', :token => token)

    committer = Gitrb::User.new($vimscripts_name, $vimscripts_email)
    puts "Processing script #{script['script_id']}: #{script['name']}"
    script['versions'].reverse.each do |version|
        author = Gitrb::User.new("#{version['author']['first_name']} #{version['author']['last_name']}",
                                 version['author']['email'], Time.new(*version['date'].split('-'), 0, 0, 0, 0))
        if find_version(version)
            puts "  skipped #{version['filename']} #{version['date']} #{version['script_version']}"
        else
            $repo.transaction(version['release_notes'], author, committer) {
                # delete all existing blobs in this commit
                $repo.root.to_a.map { |a| $repo.root.delete(a.first) }
                add_version(version, script)
                copy_file('README', "This is a mirror of #{script_id_to_url(script['script_id'])}\n\n" + script['description'] + "\n") unless $repo.root['README']
            }
            tag_version(version)
            puts "  added #{version['filename']} #{version['date']} #{version['script_version']}"
        end
    end
end


def dump_repo(repo)
    repo = repo.gsub /\/$/, ''
    ENV['GIT_DIR'] = repo
    log = `git log --pretty=fuller --decorate=full --stat`
    # remove every line with a CommitDate since that's horribly variable
    log = log.each_line.reduce([]) { |a,v| a.push(v) unless v =~ /^CommitDate: /; a }.join
    ENV.delete('GIT_DIR')
    filename = File.join($repostats_dir, File.basename(repo).gsub(/\.git$/, '') + '.stats')
    puts "Stats for #{filename}"
    File.open(filename, 'w') { |f|
        f.write log
    }
end


raise "specify some scripts to scrape" if ARGV.empty?
ARGV.each do |arg|
    if arg =~ /^\d+$/
        write_script(scrape_script(arg))
    elsif test ?f, arg
        read_script(JSON.parse(File.read(arg)))
    elsif test ?d, arg
        dump_repo(arg)
    else
        raise "Could not recognize argument #{arg}"
    end
end

