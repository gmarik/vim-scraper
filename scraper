#!/bin/env ruby

# Vimscripts scraper monster
# This command takes any mixture of arguments:
# - decimal number: the script id to scrape and save as a json file
# - .json file: the script to convert into a git repo
# - bare .git repo dir: the git repo to push to github

require 'rubygems'
require 'hpricot'
require 'open-uri'
require 'cgi'
require 'json'
require 'gitrb'
require 'zip/zipfilesystem' # rubyzip gem
require 'archive/tar/minitar' # minitar gem
require 'zlib'
require 'bzip2'
require 'mime/types'
require 'mimemagic'
require 'tmpdir'
require 'tempfile'
require 'find'

# thoughts:
# We do everything we can to make it so you can drop the repo in bundles and just have it work.
# We reset permissions on extracted files -- usually when they're different it's a mistake.


$vimscripts_name = "vim-scripts"
$vimscripts_email = 'vimscripts@rinspin.com'

$repos_dir = 'repos'
$scripts_dir = 'scripts'
$packages_dir = 'packages'

$vimdirs = %w{after autoload bin colors doc ftdetect ftplugin indent plugin syntax}
$textext = %w{c cpp csh diff h klip patch pl pm ps py rb set sh tcl txt vim}.map { |x| "\\.#{x}$" }.join('|')
$deleted_scripts = %w{548 549 550 762 1032 1129 1295 1301 1669 1789 2056 2861}

Dir.mkdir $scripts_dir unless test ?d, $scripts_dir
Dir.mkdir $repos_dir unless test ?d, $repos_dir
Dir.mkdir $packages_dir unless test ?d, $packages_dir



# http://github.com/hpricot/hpricot/issues#issue/25
# super ugly that hpricot manages to screw up charset encodings so badly.
# I'm patching hpricot directly as follows.  should probably convert this to a monkeypatch.
#
# --- a/lib/hpricot/traverse.rb	2010-08-25 02:07:55.288095773 -0700
# +++ b/lib/hpricot/traverse.rb	2010-08-25 02:08:02.403095712 -0700
# @@ -157,7 +157,7 @@
#      # HTML elements are removed.
#      def inner_text
#        if respond_to?(:children) and children
# -        children.map { |x| x.inner_text }.join
# +        children.map { |x| str = x.inner_text; str = str.dup.force_encoding('ISO-8859-1').encode('UTF-8') if str.encoding.to_s == 'ASCII-8BIT' || str.encoding.to_s == 'ISO-8859-1'; str }.join
#        else
#          ""
#        end
#
# --- a/lib/hpricot/builder.rb   2010-08-25 09:55:37.894992548 -0700
# +++ b/lib/hpricot/builder.rb   2010-08-25 09:55:23.880992337 -0700
# @@ -6,8 +6,9 @@
#  module Hpricot
#    # XML unescape
#    def self.uxs(str)
# -    str.to_s.
# -        gsub(/\&(\w+);/) { [NamedCharacters[$1] || ??].pack("U*") }.
# +    str = str.to_s
# +    str = str.dup.force_encoding('ISO-8859-1').encode('UTF-8') if str.encoding.to_s == 'ASCII-8BIT' || str.encoding.to_s == 'ISO-8859-1'
# +    str.gsub(/\&(\w+);/) { [NamedCharacters[$1] || ??].pack("U*") }.
#          gsub(/\&\#(\d+);/) { [$1.to_i].pack("U*") }
#    end
#
# Run './scraper 5' to see a script with a bunch of embedded nbsps
# that breaks hpricot horribly.
#
# encoding resources:
# http://yokolet.blogspot.com/2009/07/design-and-implementation-of-ruby-m17n.html
# http://yehudakatz.com/2010/05/05/ruby-1-9-encodings-a-primer-and-the-solution-for-rails/

module Hpricot
    module Traverse
        def inner_content
            if respond_to?(:children) and children
                children.map { |x| x.inner_content }.join
            else
                ''
            end
        end
    end

    class Elements < Array
        def inner_content
            map { |x| x.inner_content }.join
        end
    end

    class Text
        def inner_content
            CGI.unescapeHTML(content.to_s.gsub(/&nbsp;/, " "))
        end
    end

    class CData
        alias_method :inner_content, :content
    end
end


# monkeypatch remove into mimemagic, hopefully this gets pulled upstream.
# http://github.com/bronson/mimemagic/commit/e1860b1fac0187c638569bc45833adc2ca521661
class MimeMagic
    def self.remove(type)
        obj = new(type)
        obj.extensions.each { |ext| EXTENSIONS.delete(ext) }
        MAGIC.delete_if { |t, m| t == type }
        TYPES.delete(type)
    end
end
MimeMagic.remove('application/x-gmc-link')


def scrape_author(user_id)
    $authors ||= []
    unless $authors[user_id.to_i]
        doc = open("http://www.vim.org/account/profile.php?user_id=#{user_id}") { |f| Hpricot(f) }
        doc.at('td[text()="user name"]').next_sibling.inner_content
        u = { :user_id => user_id }
        u[:user_name] = doc.at('td[text()="user name"]').next_sibling.inner_content
        u[:first_name] = doc.at('td[text()="first name"]').next_sibling.inner_content
        u[:last_name] = doc.at('td[text()="last name"]').next_sibling.inner_content
        u[:email] = doc.at('td[text()="email"]').next_sibling.inner_content
        u[:homepage] = doc.at('td[text()="homepage"]').next_sibling.inner_content
        $authors[user_id.to_i] = u
    end
    return $authors[user_id.to_i]
end


def script_id_to_url(script_id)
    "http://www.vim.org/scripts/script.php?script_id=#{script_id}"
end


def scrape_script(script_id)
    # hard-code the scripts that claim to be deleted
    if $deleted_scripts.include? script_id.to_s
        puts "Skipped #{script_id} -- deleted."
        return nil
    end

    doc = open(script_id_to_url(script_id)) { |f| Hpricot(f) }
    if doc.search('title').inner_text == "Error : vim online"
        puts "Skipped #{script_id} -- doesn't exist."
        return nil
    end

    s = {:script_id => script_id}
    s[:name], s[:summary] = doc.search('.txth1').inner_content.split(" : ", 2)
    s[:script_type] = doc.at('td[text()="script type"]').parent.next_sibling.children.first.inner_content
    s[:description] = doc.at('td[text()="description"]').parent.next_sibling.children.first.inner_content.gsub("\r", "\n")
    s[:install_details] = doc.at('td[text()="install details"]').parent.next_sibling.children.first.inner_content.gsub("\r", "\n")
    # reject links with targets so download links in the description don't appear to be a version (script 1843)
    s[:versions] = doc.search('a[@href*="download_script.php?"]').select { |e| e.attributes['target'].empty? }.to_a.map do |a|
        v = {:url => 'http://www.vim.org/scripts/' + a.attributes['href'],
            :filename => a.inner_content}
        row = a.parent
        v[:script_version] = row.siblings_at(1).inner_content
        v[:date] = row.siblings_at(2).inner_content
        v[:vim_version] = row.siblings_at(3).inner_content
        v[:author] = scrape_author(row.siblings_at(4).at('a').attributes['href'].match(/\d+/)[0])
        v[:release_notes] = row.siblings_at(5).inner_content.gsub("\r", "\n")
        v
    end
    s
end


def fix_encoding(h)
    # see the Hpricot monkey patch above.  It gave us random encodings,
    # we need to force them back to their default before converting to utf8.
    # ugly!!
    if h.kind_of? Hash
        o = Hash.new
        h.each_pair { |k,v| o[fix_encoding(k)] = fix_encoding(v) }
        o
    elsif h.kind_of? Array
        a = Array.new
        h.each { |v| a.push fix_encoding(v) }
        a
    elsif h.kind_of? String
        if h.encoding.to_s == 'ASCII-8BIT' || h.encoding.to_s == 'ISO-8859-1'
            h = h.dup.force_encoding('ISO-8859-1').encode('UTF-8')
        end
        h
    else
        h
    end
end


def check_encoding(h)
    # recursively prints the encoding of every key/value/element etc
    if h.kind_of? Hash
        h.each_pair { |k,v| check_encoding(k); check_encoding(v) }
    elsif h.kind_of? Array
        h.each { |v| check_encoding(v) }
    elsif h.kind_of? String
        puts "#{h.encoding}: #{h[0..50]}"
    else
        h
    end
end


def filenameify(s)
    # replace unsafe path chars.  keep posessive Michaels, not Michael-s
    s.gsub(/'s/i, 's').gsub(/[^ A-Za-z0-9_\-!#\@\$^%&:;<?>+=(){|},.\[\]]/, '-')
end


def gittagify(s)
    # replace any chars git might take issue with (space, backslash, ^:)?]
    # git doesn't like it when a tag begins or ends with a period
    s.gsub(/[^A-Za-z0-9_\-!#\@\$%&;<>+=(){|},.\]]/, '-').gsub(/^\./, '0.').gsub(/\.$/, '.0')
end


def script_version(version)
    # some scripts don't assign a version so just use the date
    s = version['script_version']
    s = version['date'] if s =~ /^\s*$/
    s
end


def write_script(script)
    return unless script
    filename = File.join($scripts_dir, "#{'%04d' % script[:script_id]} - #{filenameify(script[:name])}.json")
    puts "Scraped #{filename}"
    File.open(filename, 'w') { |f|
        farg = fix_encoding(script)
        # check_encoding(farg)
        f.write(JSON.pretty_generate(farg))
    }
end


def download_file(url, dest)
    puts "  downloading #{url} to #{dest}"
    open(url, 'rb') { |u|
        File.open(dest, 'wb') { |f|
            f.write(u.read)
        }
    }
end


def copy_file(filename, contents)
    raise "no data in #{filename}: #{contents.inspect}" unless contents
    $repo.root[filename] = Gitrb::Blob.new(:data => contents)
end


def cleanpath(path)     # lifted from git-wiki
    path = path.gsub /^[\/\s]*/, ''
    names = path.split('/').reject { |str| str =~ /^\s*$/ }
    i = 0
    while i < names.length
        case names[i]
        when '..'
            names.delete_at(i)
            if i>0
                names.delete_at(i-1)
                i-=1
            end
        when '.'
            names.delete_at(i)
        else
            i+=1
        end
    end
    names.join('/')
end


def smart_copy_file(script, filename, contents)
    filename = cleanpath(filename)
    if filename =~ /^[^\/]+\.vim/
        # a .vim file in the root directory
        case script['script_type']
        when 'color scheme' then copy_file("colors/" + filename, contents)
        when 'ftplugin' then copy_file("ftplugin/" + filename, contents)
        when 'game' then copy_file("plugin/" + filename, contents)
        when 'indent' then copy_file("indent/" + filename, contents)
        when 'syntax' then copy_file("syntax/" + filename, contents)
        when 'utility' then copy_file("plugin/" + filename, contents)
        else raise "Don't know where to put #{filename} for #{script['script_type']}"
        end
    elsif filename =~ /^[^\/]+\.txt/
        copy_file("doc/" + filename, contents)
    elsif filename =~ /^[^\/]+\/(#{$vimdirs.join('|')})\/([^\/]+)$/
        # developer put vimfiles in a subdir, i.e. fixit/plugin/fixit.vim.
        copy_file("#{$1}/#{$2}", contents)
    else
        copy_file(filename, contents)
    end
end


def copy_filesystem(script, dir)
    Find.find(dir) do |path|
        next if test(?d, path)
        localpath = path.sub(dir, '').sub(/^\/+/, '')
        next if block_given? && yield(localpath)
        smart_copy_file(script, localpath, File.read(path))
    end
end


def extract_vimball(script, vimball)
    Dir.mktmpdir($vimscripts_name) do |tmpdir|
        cmd = ['/usr/bin/vim', vimball, '-X', '-n', '-c', ':set nomore', '-c', ":set runtimepath=#{tmpdir},$VIMRUNTIME", '-c', ':so %', '-c', ':q']
        raise "couldn't run #{cmd.join(' ')}: #{$?}" unless system(*cmd)
        copy_filesystem(script, tmpdir) { |path| path == '.VimballRecord' || path == 'doc/tags' }
    end
end


def unvimball(script, vimball)
    if script['script_id'].to_i == 293
        # special case to not have to hit return when unpacking.  vimballs suck bad.
        Tempfile.open($vimscripts_name) do |ttfile|
            ball = File.read(vimball)
            ball.force_encoding("ASCII-8BIT")
            ball.gsub!(/call input\(\"\<Hit Return to continue\>\"\)/, '')
            ttfile.write(ball)
            ttfile.close
            extract_vimball(script, ttfile.path)
        end
    elsif %w{1318 1609 1952}.include? script['script_id'].to_s
        # apparently vimball dies badly if called on a file with the wrong line endings
        Tempfile.open($vimscripts_name) do |ttfile|
            ball = File.read(vimball)
            ball.force_encoding("ASCII-8BIT")
            ball.gsub!("\r", '')
            ttfile.write(ball)
            ttfile.close
            extract_vimball(script, ttfile.path)
        end
    else
        extract_vimball(script, vimball)
    end
end


def unrar(script, rarpath)
    Dir.mktmpdir($vimscripts_name) do |tmpdir|
        fullpath = File.expand_path(rarpath)
        Dir.chdir(tmpdir) {
            cmd = ['/usr/bin/unrar', 'x', fullpath]
            raise "couldn't run #{cmd.join(' ')}: #{$?}" unless system(*cmd)
        }
        copy_filesystem(script, tmpdir)
    end
end


def copy_zipfile(script, zip_path)
    Zip::ZipFile.open(zip_path) do |zipfile|
        zipfile.each do |entry|
            next unless entry.file?
            raise "add symlinks!" if entry.symlink?
            smart_copy_file(script, entry.name, entry.get_input_stream.read)
        end
    end
end


def copy_tarfile(script, tarfile)
    Archive::Tar::Minitar::Reader.open(tarfile) do |tf|
        tf.each_entry do |entry|
            next unless entry.file?
            smart_copy_file(script, entry.full_name, entry.read || '')
        end
    end
end


def ungzip(file)
    Zlib::GzipReader.open(file) { |gz| yield(gz) }
end


def unbzip2(file)
    Bzip2::Reader.open(file) { |bz| yield(bz) }
end


def download_package(version, script)
    pkgname = "#{version['date']} #{filenameify(script_version(version))} #{filenameify(version['filename'])}"
    pkgdir = File.join($packages_dir, "#{'%04d' % script['script_id']} - #{filenameify(script['name'])}")
    Dir.mkdir pkgdir unless test ?d, pkgdir
    pkgfile = File.join(pkgdir, pkgname)
    download_file(version['url'], pkgfile) unless test ?f, pkgfile
    return pkgfile
end


def sense_zipped_file(script, filename, infile)
    # sense the payload of a gz or bz2 file.  don't want to recurse into sense_file: too complex.
    contents = infile.read
    if MimeMagic.by_magic(contents) == 'application/x-tar'
        copy_tarfile(script, StringIO.new(contents))
    elsif contents[0..512] =~ /^\bUseVimball\s*$/
        Tempfile.open($vimscripts_name) do |ttfile|
            ttfile.write(contents)
            ttfile.close
            unvimball(script, ttfile.path)
        end
    else
        smart_copy_file(script, filename, contents)
    end
end


def is_some_sort_of_zipfile(type)
    type.include?('application/zip') || type.include?('application/x-gzip') || type.include?('application/x-bzip')
end


def sense_file(actual_name, pkgfile)
    # some files lie about their type (claim to be .zips but are just .vim files).  fix em.
    extension_type = MIME::Types.type_for(actual_name)
    magic_type = File.open(pkgfile) { |f| MimeMagic.by_magic(f) }
    if ( extension_type.include?(magic_type) ||
        (extension_type.include?('application/x-bzip2') && magic_type == 'application/x-bzip') ||
        (extension_type.include?('application/x-rar-compressed') && magic_type == 'application/x-rar') )
        # we're good, extension and magic match up
    else
        # need to figure out what's going on and fix it.
        if (magic_type.nil? || magic_type.text?) && actual_name =~ /#{$textext}/
            # no problem, it's a textfile
        elsif actual_name =~ /\.vba$/
            # arg, a vimball.  let it through.  see sense_zipped_file for vimball sensing.
        elsif actual_name =~ /^[^a-z]*\.VIM$/
            # i guess dos users might do everything in caps
            actual_name.downcase!
        elsif ( (magic_type == 'application/x-perl' && %w{dtags qt2vimsyntax multiAPIsyntax colortest dtd2vim}.include?(actual_name)) ||
                (magic_type == 'application/x-ruby' && %w{colorize}.include?(actual_name)) ||
                magic_type == 'application/x-shellscript' ||
                magic_type == 'application/xml' ||
                (magic_type == nil && %w{vimopen}.include?(actual_name)) ||
                %w{zshrc vimrc _vimrc cleanswap cvsvimdiff vmake}.include?(actual_name) ||
                actual_name =~ /\.dict$/ || %w{pydiction xdebug2}.include?(actual_name) ||  # dictionaries
                actual_name =~ /\.applescript$/ ||
                magic_type == 'application/x-ms-dos-executable' )
            # names and magic have failed us, copy these files over raw
            copy_file(actual_name, File.read(pkgfile))
            actual_name = nil
        elsif is_some_sort_of_zipfile(extension_type)
            # extension claims zipfile but magic disagrees
            actual_name.sub!(/\.zip$|\.tar\.gz$|\.tar\.bz2?$|\.tgz$|\.tbz2?$/i, '')
            if magic_type == 'text/x-python'
                actual_name += '.py'
            elsif magic_type.nil? || magic_type.text?   # chances are it's a vimscript...?
                actual_name += '.vim'   # http://www.vim.org/scripts/script.php?script_id=29
            elsif magic_type == 'application/x-tar'
                actual_name += '.tar'
            else
                raise "unknown failed zip type for #{actual_name}: #{magic_type}"
            end
        elsif magic_type == 'application/zip'
            actual_name += '.zip'
        elsif magic_type == 'application/x-gzip'
            actual_name += '.gz'
        elsif magic_type == 'application/x-bzip'
            actual_name += '.bz2'
        elsif magic_type == 'application/x-macbinary'
            copy_file(actual_name + '.macbinary', File.read(pkgfile))
            actual_name = nil
        elsif !magic_type && actual_name =~ /^exUtility-[0-9.]*.tar$/
            # odd that magic couldn't sense this valid tarfile.  owell, process it as normal.
        else raise "differing mime types for #{actual_name}, ext claims #{extension_type} but magic is #{magic_type.inspect}"
        end
    end
    return actual_name
end


def add_version(version, script)
    # adds all the files in the package to the $repo
    pkgfile = download_package(version, script)
    actual_name = sense_file(version['filename'], pkgfile)

    case actual_name
    when nil then # do nothing
    when /#{$textext}/ then smart_copy_file(script, actual_name, File.read(pkgfile))
    when /\.zip$/i then copy_zipfile(script, pkgfile)
    when /\.tar$/ then File.open(pkgfile, 'r') { |file| copy_tarfile(script, file) }
    when /\.t?gz$/i then ungzip(pkgfile) { |contents| sense_zipped_file(script, version['filename'].sub(/\.t?gz$/, ''), contents) }
    when /\.t?bz2?$/i then unbzip2(pkgfile) { |contents| sense_zipped_file(script, version['filename'].sub(/\.t?bz2?$/, ''), contents) }
    when /\.rar$/ then unrar(script, pkgfile)
    when /\.vba$/ then unvimball(script, pkgfile)
    else raise "unknown filetype: #{actual_name}"
    end
end


def tag_version(version)
    ENV['GIT_COMMITTER_NAME'] = $vimscripts_name
    ENV['GIT_COMMITTER_EMAIL'] = $vimscripts_email
    # don't need to chdir before git tag since Gitrb set GIT_DIR.  :-/
    sver = script_version(version)
    $repo.git_tag('-a', gittagify(sver), '-m', "tag #{sver}")
    ENV.delete('GIT_COMMITTER_NAME')
    ENV.delete('GIT_COMMITTER_EMAIL')
end


def find_version(version)
    tagname = gittagify(script_version(version))
    tagref = "#{$repo.path}/refs/tags/#{tagname}"
    return nil unless test ?f, tagref
    id = File.read(tagref)
    tag = $repo.get(id)
    raise "not a commit tag" unless tag.tagtype == 'commit'
    return tag
end


def copy_tree(script, tree, inpath=[])
    tree.to_a.each { |name, value|
        path = inpath + [name]
        if value.type == :blob
            smart_copy_file(script, path.join('/'), value.data)
        else
            copy_tree(script, value, path)
        end
    }
end


def check_for_lone_dir(script)
    return unless $repo.root.count == 1
    loner = $repo.root.first.first
    return if $vimdirs.include? loner
    if $repo.root[loner].type == :tree
        # copy contents of the directory into the root
        copy_tree script, $repo.root.delete(loner)
    end
end


def check_for_readme_file
    # we drop a README file into each repo.  don't want to conflict with one already there.
    $repo.root.to_a.each { |name, value|
        if name =~ /^README$/i
            raise "already have a readme.orig!" if $repo.root.to_a.find { |n,v| n =~ /^readme\.orig$/i }
            $repo.root[name + '.orig'] = $repo.root.delete(name)
        end
    }
end


def read_script(script)
    $repo_path = File.join($repos_dir, "#{'%04d' % script['script_id']} - #{filenameify(script['name'])}.git")
    # if gitrb is dying on the following line, you need this fix:
    #   http://github.com/bronson/gitrb/commit/ae931ad7fe8309bcd2c4b9cc582c1500fa152e8d
    $repo = Gitrb::Repository.new(:path => $repo_path, :bare => true, :create => true)

    # token = File.read('token').chomp
    # github = Octopussy::Client.new(:login => 'vim-scripts', :token => token)

    committer = Gitrb::User.new($vimscripts_name, $vimscripts_email)
    puts "Processing script #{script['script_id']}: #{script['name']}"
    script['versions'].reverse.each do |version|
        author = Gitrb::User.new("#{version['author']['first_name']} #{version['author']['last_name']}",
                                 version['author']['email'], Time.new(*version['date'].split('-'), 0, 0, 0, 0))
        if find_version(version)
            puts "  skipped #{version['filename']} #{version['date']} #{script_version(version)}"
        else
            puts "  adding #{version['filename']} #{version['date']} #{script_version(version)}"
            $repo.transaction(version['release_notes'], author, committer) {
                # delete all existing blobs since we replace everything with the new commit
                $repo.root.to_a.map { |name,value| $repo.root.delete(name) }
                add_version(version, script)
                check_for_lone_dir(script)
                check_for_readme_file
                copy_file('README', "This is a mirror of #{script_id_to_url(script['script_id'])}\n\n" + script['description'] + "\n") unless $repo.root['README']
            }
            tag_version(version)
        end
    end
end


def push_repo(repo)
    raise "not yet"
end


raise "specify some scripts to scrape" if ARGV.empty?
ARGV.each do |arg|
    if arg =~ /^\d+$/
        write_script(scrape_script(arg))
    elsif test ?f, arg
        read_script(JSON.parse(File.read(arg)))
    elsif test ?d, arg
        push_repo(arg)
    else
        raise "Could not recognize argument #{arg}"
    end
end

